import base64
from collections import deque, Counter
from pathlib import Path
from xml.etree.ElementTree import Element

import upnpclient
from urllib.parse import urlparse
from xml.etree import ElementTree
from functools import cache

from vibin import VibinNotFoundError
from vibin.mediaservers import MediaServer
from vibin.models import MediaServerState, Album, Artist, Track, UPnPServiceSubscriptions, MediaBrowseSingleLevel, \
    MediaFolder
from vibin.types import UpdateMessageHandler, MediaId, UPnPProperties, MediaType

# -----------------------------------------------------------------------------
# Implementation of MediaServer, using USB drives attached to a CXNv2.
#
# Vibin won't auto-detect any media library hosted by the CXNv2. To enable this
# feature, use `--media-server` on the command line, giving the friendly name
# of the CXNv2.
#
# Implementation notes:
#
# The CXNv2 provides a simple implementation of ContentDirectory exposing the
# directory and file structure of any attached USB drives. Experimentally:
#   * Playable tracks have type `object.item.audioItem.musicTrack`
#   * Directories with tracks have type `object.container.album.musicAlbum`
#   * Other directories have type `object.container`
# I'm not sure how the CXNv2 would handle directories containing a mix of
# tracks from different albums.
#
# Albums don't seem to come with the artist name or genre, and these are
# inferred from the album's tracks.
#
# Ids generated by the CXNv2 are **not stable** and change when the device
# cycles through standby mode. They come in the following forms:
#   * ContentDirectory ids are, for example, `8:0_1_11_0`. The `0_1_11_0` part
#     represents navigation through the filesystem using 0-based indexes - the
#     zero'th attached device, the first directory, the eleventh subdirectory
#     etc. The number before the colon is incremented when the device cycles
#     through standby mode.
#   * Resource URLs are, for example,
#     `file:///tmp/usm/27/music/Kosheen/Resist/01%20-%20Demonstrate.mp3`. In
#     this example, the `file:///tmp/usm/` appears fixed, the number changes
#     when the device cycles through standby, and the remaining path is just
#     the path through the USB filesystem.
#   * Images are hosted at, for example,
#     `http://<ip-address>:80/album-art-f85f?id=11:11`. The `album-art-f85f`
#     part seems to be fixed but the id parameter changes when the device
#     cycles through standby.
#
# Neither the ContentDirectory nor the images are available while the device is
# in standby mode. Ids and images are cleared when the device is put into
# standby, and only regenerated on demand. If we know that a track lies at
# 0_1_2_3, and we know that the current prefix is '6:', then it is an error to
# request details for '6:0_1_2_3' without first browsing the root ('0'), '6:0',
# '6:0_1', and '6:0_1_2'. Similarly, images don't exist (and aren't assigned an
# id) until their parent directory is browsed for the first time after the
# device comes out of standby. This regeneration process is rather slow,
# presumably while the device extracts images from the playable files.
# -----------------------------------------------------------------------------

# The present implementation is quite naive and doesn't include workarounds for
# the limitations described above.
#
# TODO:
#   * Tolerate standby mode. The present implementation assumes that the ids
#     provided by the CXNv2 are stable.
#   * Provide occasional reassuring log messages when indexing the
#     ContentDirectory, which can take a long time.

_xml_namespaces = {
    "didl": "urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/",
    "dc": "http://purl.org/dc/elements/1.1/",
    "upnp": "urn:schemas-upnp-org:metadata-1-0/upnp/",
    "dlna": "urn:schemas-dlna-org:metadata-1-0/",
}

class _BrowseResult(object):
    """A result from ContentDirectory.BrowseDirectChildren, representing an
    item in the content directory.
    """
    def __init__(self, element: Element):
        res = element.find("didl:res", namespaces=_xml_namespaces)
        self.id = element.attrib["id"]
        self.parentId = element.attrib["parentID"]
        self.type = _BrowseResult._property(element, "upnp:class")
        self.title = _BrowseResult._property(element, "dc:title")
        self.album = _BrowseResult._property(element, "upnp:album")
        self.artist = _BrowseResult._property(element, "upnp:artist")
        self.genre = _BrowseResult._property(element, "upnp:genre")
        self.original_track_number = _BrowseResult._int_property(element, "upnp:originalTrackNumber")
        self.album_art_uri = _BrowseResult._property(element, "upnp:albumArtURI")
        self.duration = res.attrib["duration"] if isinstance(res, ElementTree.Element) else None
        self.resource = _BrowseResult._property(element, "didl:res")

    @staticmethod
    def _property(element, field):
        """Extract a field's value from the given element's XML."""
        find_result = element.find(field, namespaces=_xml_namespaces)
        if isinstance(find_result, ElementTree.Element):
            return find_result.text or None
        else:
            return None

    @staticmethod
    def _int_property(element, field):
        """Extract a field's value from the ElementTree, parsed as an int."""
        as_string = _BrowseResult._property(element, field)
        if as_string:
            return int(as_string)
        else:
            return None


class _Catalogue(object):
    """Indexes all the Tracks, Albums and Artist objects found in the
    ContentDirectory."""
    def __init__(self, results: list[_BrowseResult]):
        self.tracks = [self.create_track(result) for result in results
                       if result.type == "object.item.audioItem.musicTrack"]
        self.tracks_by_id = {track.id: track for track in self.tracks}
        self.tracks_by_album_id = _Catalogue._group_tracks_by_album_id(self.tracks)
        self.track_id_by_resource = {result.resource : result.id for result in results
                                     if result.resource and result.type == "object.item.audioItem.musicTrack"}

        self.albums = [self.create_album(result) for result in results
                       if result.type == "object.container.album.musicAlbum"]
        self.albums_by_id = {album.id: album for album in self.albums}

        self.artists = [self.create_artist(name) for name in
                        { result.artist for result in results if result.artist }
                        ]
        self.artists_by_id = {artist.id: artist for artist in self.artists}
        self.artists.sort(key = lambda a: a.title)

    def create_track(self, result: _BrowseResult) -> Track:
        """Creates a new Track with information from this _BrowseResult"""
        return Track(
            id = result.id,
            albumId = result.parentId,
            title = result.title,
            artist = result.artist,
            album = result.album or "Unknown Album",
            duration = result.duration,
            genre = result.genre,
            album_art_uri = result.album_art_uri,
            original_track_number = result.original_track_number,
            resource = result.resource
        )

    def create_album(self, result: _BrowseResult) -> Album:
        """Creates a new Album with information from this _BrowseResult."""
        return Album(
            id = result.id,
            title = result.title,
            artist = result.artist or self._guess_artist(result.id),
            genre = result.genre or self._guess_genre(result.id),
            album_art_uri = result.album_art_uri,
        )

    def _guess_artist(self, album_id: MediaId):
        """Infers the artist name from an album's tracks.

        If a single artist is responsible for most of the tracks, assume the
        album is credited to that artist. Otherwise, use the name `Various
        Artists`.
        """
        tracks = self.tracks_by_album_id[album_id]
        if not tracks:
            return "Unknown"
        (artist, count) = Counter([t.artist for t in tracks]).most_common(1)[0]
        if artist and count > len(tracks) / 2:
            return artist
        else:
            return "Various Artists"

    def _guess_genre(self, album_id: MediaId):
        """Infers a genre from an album's tracks.

        If most of the tracks share a genre, uses that genre. Otherwise, return
        the string 'Unknown' which the UI expects in the absense of a genre.
        """
        tracks = self.tracks_by_album_id[album_id]
        if not tracks:
            return "Unknown"
        (genre, count) = Counter([t.genre for t in tracks]).most_common(1)[0]
        if genre and count > len(tracks) / 2:
            return genre
        else:
            return "Unknown"

    def create_media_folder(self, result: _BrowseResult) -> MediaFolder:
        """Creates a new MediaFolder with information from this _BrowseResult."""
        return MediaFolder(
            title = result.title,
            album_art_uri = result.album_art_uri,
            artist = result.artist,
            genre = result.genre,
        )

    def create_model_object(self, result: _BrowseResult) -> Track | Album | MediaFolder:
        """Returns a model object for this _BrowseResult."""
        match result.type:
            case "object.item.audioItem.musicTrack":
                return self.create_track(result)
            case "object.container.album.musicAlbum":
                return self.create_album(result)
            case _:
                return self.create_media_folder(result)

    def create_artist(self, name: str):
        """Creates an Artist object given a name.

        Ids are synthetic and based simply on the name.
        """
        return Artist(
            id = base64.urlsafe_b64encode(name.encode()),
            title = name,
            genre = "Unknown",
            album_art_uri = None
        )

    @staticmethod
    def _group_tracks_by_album_id(tracks: list[Track]) -> dict[MediaId, list[Track]]:
        out = {}
        for track in tracks:
            if track.albumId not in out: out[track.albumId] = []
            out[track.albumId].append(track)

        return out


class CXNv2(MediaServer):
    """Implementation of MediaServer using USB storage attached to a Cambridge
    Audio CXNv2 Streamer."""

    model_name = "CXNv2"

    def __init__(
            self,
            device: upnpclient.Device,
            upnp_subscription_callback_base: str | None = None,
            on_update: UpdateMessageHandler | None = None,
    ):
        self._device: upnpclient.Device = device

    @property
    def name(self) -> str:
        return self._device.friendly_name

    @property
    def device(self):
        return self._device

    @property
    def device_state(self) -> MediaServerState:
        return MediaServerState(name=self._device.friendly_name)

    @property
    def device_udn(self) -> str:
        return self._device.udn.removeprefix("uuid:")

    def on_startup(self) -> None:
        pass

    def on_shutdown(self) -> None:
        pass

    # -------------------------------------------------------------------------
    # System

    def clear_caches(self):
        self._catalogue.cache_clear()

    @property
    def url_prefix(self):
        media_location = self.device.location
        parsed_location = urlparse(media_location)

        return f"{parsed_location.scheme}://{parsed_location.netloc}"

    # -------------------------------------------------------------------------
    # Settings - unused in this implementation

    @property
    def all_albums_path(self) -> str | None:
        return None

    @all_albums_path.setter
    def all_albums_path(self, path: str):
        pass

    @property
    def new_albums_path(self) -> str | None:
        return None

    @new_albums_path.setter
    def new_albums_path(self, path: str):
        pass

    @property
    def all_artists_path(self) -> str | None:
        return None

    @all_artists_path.setter
    def all_artists_path(self, path: str):
        pass

    # -------------------------------------------------------------------------
    # Media

    @property
    def albums(self) -> list[Album]:
        """Get details on all Albums on the Media Server."""
        return self._catalogue().albums

    @property
    def new_albums(self) -> list[Album]:
        """Get details on all new Albums on the Media Server.

        Unsupported - just returns an empty list.
        """
        return []

    def album(self, album_id: MediaId) -> Album:
        """Get details on an Album by MediaId."""
        return self._catalogue().albums_by_id[album_id]
        pass

    def album_tracks(self, album_id: MediaId) -> list[Track]:
        """Get details on all Tracks for an Album on the Media Server."""
        return self._catalogue().tracks_by_album_id[album_id]

    @property
    def artists(self) -> list[Artist]:
        """Get details on all Artists on the Media Server."""
        return self._catalogue().artists

    def artist(self, artist_id: MediaId) -> Artist:
        """Get details on an Artist by MediaId."""
        return self._catalogue().artists_by_id[artist_id]

    @property
    def tracks(self) -> list[Track]:
        """Get details on all Tracks on the Media Server."""
        return self._catalogue().tracks

    def track(self, track_id: MediaId) -> Track:
        """Get details on a Track by MediaId."""
        return self._catalogue().tracks_by_id[track_id]

    def ids_from_filename(
            self, filename: str, ids: list[MediaType]
    ) -> dict[MediaType, MediaId | None]:
        """Extract Media Ids from the given filename."""
        if filename in self._catalogue().track_id_by_resource:
            track_id = self._catalogue().track_id_by_resource[filename]
            return {
                "track": track_id,
                "album": self._catalogue().tracks_by_id[track_id].albumId
            }
        else:
            return {
                "track": None,
                "album": None
            }

    # -------------------------------------------------------------------------
    # Browsing

    def get_path_contents(
            self, path: Path
    ) -> list[MediaFolder | Artist | Album | Track] | Track | None:
        """Retrieve the contents of the given path on the Media Server."""
        id = "0"
        match = None
        for part in path.parts:
            matches = [child for child in self._browse_direct_children(id)
                       if child.title == part]
            if len(matches) == 0:
                return None
            else:
                match = matches[0]
                id = match.id

        if match and match.type == "object.item.audioItem.musicTrack":
            return self._catalogue().create_track(match)
        else:
            return [self._catalogue().create_model_object(child)
                    for child in self._browse_direct_children(id)]

    def children(self, parent_id: MediaId = "0") -> MediaBrowseSingleLevel:
        """Retrieve information on all children of the given `parent_id`."""
        return MediaBrowseSingleLevel(
            id = parent_id,
            children = [child.__dict__
                        for child in self._browse_direct_children(parent_id)],
        )

    def get_metadata(self, id: MediaId):
        """Get Media Server metadata on an item by MediaId."""
        try:
            browse_result = self._device.ContentDirectory.Browse(
                ObjectID=id,
                BrowseFlag="BrowseMetadata",
                Filter="*",
                StartingIndex=0,
                RequestedCount=0,
                SortCriteria="",
            )
            return browse_result["Result"]
        except upnpclient.soap.SOAPProtocolError as e:
            raise VibinNotFoundError(f"Could not find media id {id}")

    # -------------------------------------------------------------------------
    # UPnP

    def subscribe_to_upnp_events(self) -> None:
        pass

    def upnp_properties(self) -> UPnPProperties:
        return {}

    @property
    def upnp_subscriptions(self) -> UPnPServiceSubscriptions:
        return {}

    def on_upnp_event(self, service_name: str, event: str):
        pass

    # -------------------------------------------------------------------------
    # Recursively index the ContentDirectory

    @cache
    def _catalogue(self) -> _Catalogue:
        ids_to_fetch = deque(["0"])
        processed_ids = set()
        browse_results = []

        while ids_to_fetch:
            id = ids_to_fetch.popleft()
            processed_ids.add(id)
            for child in self._browse_direct_children(id):
                browse_results.append(child)
                if (child.type.startswith("object.container")
                        and not child.id in processed_ids):
                    ids_to_fetch.append(child.id)

        return _Catalogue(browse_results)

    def _browse_direct_children(self, id) -> list[_BrowseResult]:
        """Fetches children of the given id, using ContentDirectory.Browse."""

        # Note: the ContentDirectory spec says that RequestedCount can be zero
        # to request all entries. CXNv2 doesn't honour this - instead, use a
        # high RequestedCount and potentially repeat the call.
        response = self._device.ContentDirectory.Browse(
            ObjectID=id,
            BrowseFlag="BrowseDirectChildren",
            Filter="*",
            StartingIndex=0,
            RequestedCount=10000,
            SortCriteria="",
        )
        if response["TotalMatches"] > 10000:
            response = self._device.ContentDirectory.Browse(
                ObjectID=id,
                BrowseFlag="BrowseDirectChildren",
                Filter="*",
                StartingIndex=0,
                RequestedCount=response["TotalMatches"],
                SortCriteria="",
            )

        return [_BrowseResult(result)
                for result in ElementTree.fromstring(response["Result"])]
